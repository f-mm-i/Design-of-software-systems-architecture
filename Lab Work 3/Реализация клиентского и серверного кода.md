# Применение основных принципов разработки
### 1. Клиентский код (React Native / TypeScript)

#### 1.1. Общий HTTP-клиент (DRY, KISS, DIP)

```ts
// httpClient.ts
export interface HttpClient {
  get<T>(url: string): Promise<T>;
  post<T>(url: string, body: unknown): Promise<T>;
}

export class FetchHttpClient implements HttpClient {
  constructor(private readonly baseUrl: string) {}

  async get<T>(url: string): Promise<T> {
    const response = await fetch(this.baseUrl + url);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return response.json() as Promise<T>;
  }

  async post<T>(url: string, body: unknown): Promise<T> {
    const response = await fetch(this.baseUrl + url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return response.json() as Promise<T>;
  }
}
```

* **KISS:** минимум логики – только базовые операции `get`/`post`, ничего лишнего.
* **DRY:** единая реализация обработки ошибок и JSON, вместо дублирования кода в каждом экране.
* **SOLID – DIP:** остальной код зависит от абстракции `HttpClient`, а не от `fetch`.

#### 1.2. API Handler для карт (SRP, YAGNI)

```ts
// mapApi.ts
export interface MapPayload {
  title: string;
  description: string;
  elements: Array<{
    content: string;
    type: "point" | "area" | "note";
    x: number;
    y: number;
    color: string;
    size: number;
    mediaUrl?: string;
  }>;
}

export interface CreatedMapResponse {
  id: string;
}

export class MapApi {
  constructor(private readonly http: HttpClient) {}

  createMap(payload: MapPayload): Promise<CreatedMapResponse> {
    return this.http.post<CreatedMapResponse>("/maps", payload);
  }
}
```

* **SRP (SOLID):** `MapApi` отвечает только за взаимодействие с backend по поводу карт.
* **YAGNI:** реализован только `createMap`, без сложных фильтров/поиска, которые пока не нужны.
* **KISS:** структура данных проста, нет лишних вложенностей.

#### 1.3. Использование в редакторе карты (SoC, DRY)

```ts
// useSaveMap.ts – React hook
import { useState } from "react";

export function useSaveMap(mapApi: MapApi) {
  const [isSaving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function saveMap(payload: MapPayload) {
    setSaving(true);
    setError(null);
    try {
      await mapApi.createMap(payload);
    } catch (e) {
      setError((e as Error).message);
    } finally {
      setSaving(false);
    }
  }

  return { saveMap, isSaving, error };
}
```

* **DRY:** логика сохранения/ошибок вынесена в hook, может переиспользоваться несколькими экранами.
* **Separation of Concerns (SoC):** UI-компоненты отвечают за отображение, hook – за бизнес-логику сохранения.

---

### 2. Серверный код (Node.js / TypeScript, условно – Cloud Functions)

#### 2.1. Модели домена (KISS)

```ts
// domain/map.ts
export interface Map {
  id: string;
  userId: string;
  title: string;
  description: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface MapElement {
  id: string;
  mapId: string;
  content: string;
  type: "point" | "area" | "note";
  x: number;
  y: number;
  color: string;
  size: number;
  createdAt: Date;
  mediaUrl?: string;
}
```

* **KISS:** простые интерфейсы без лишних методов и наследования – только данные.

#### 2.2. Репозитории (SRP, DIP, DRY)

```ts
// repositories/mapRepository.ts
export interface MapRepository {
  createMap(
    map: Omit<Map, "id" | "createdAt" | "updatedAt">,
    elements: Omit<MapElement, "id" | "createdAt">[]
  ): Promise<string>;
}
```

```ts
// repositories/firestoreMapRepository.ts
import { firestore } from "./firebase";

export class FirestoreMapRepository implements MapRepository {
  async createMap(map, elements): Promise<string> {
    const batch = firestore.batch();
    const mapRef = firestore.collection("maps").doc();

    batch.set(mapRef, {
      userId: map.userId,
      title: map.title,
      description: map.description,
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    elements.forEach(el => {
      const elRef = mapRef.collection("elements").doc();
      batch.set(elRef, {
        ...el,
        createdAt: new Date(),
      });
    });

    await batch.commit();
    return mapRef.id;
  }
}
```

* **SRP:** класс отвечает только за запись данных в Firestore.
* **DRY:** единая точка доступа к коллекциям `maps` и `elements`.
* **DIP:** остальной код зависит от интерфейса `MapRepository`, а не от конкретной реализации Firestore.

#### 2.3. Сервис приложения (SOLID – SRP, OCP)

```ts
// services/mapService.ts
export class MapService {
  constructor(private readonly repo: MapRepository) {}

  async createMapForUser(
    userId: string,
    payload: MapPayload
  ): Promise<string> {
    // простая валидация (KISS)
    if (!payload.title.trim()) {
      throw new Error("Map title is required");
    }

    const map = {
      userId,
      title: payload.title,
      description: payload.description ?? "",
    };

    const elements = payload.elements.map(e => ({
      mapId: "", // заполнится репозиторием
      content: e.content,
      type: e.type,
      x: e.x,
      y: e.y,
      color: e.color,
      size: e.size,
      mediaUrl: e.mediaUrl,
    }));

    return this.repo.createMap(map, elements);
  }
}
```

* **SRP:** сервис занимается бизнес-логикой (валидация, подготовка данных), не зная деталей БД.
* **OCP:** при добавлении, например, логирования или авто-маршрутов можно расширять сервис, не меняя интерфейс `MapRepository`.
* **KISS:** логика создания карты понятна и не перегружена.

#### 2.4. HTTP-обработчик (KISS, SoC)

```ts
// handlers/createMapHandler.ts
import { Request, Response } from "express";

export function createMapHandler(mapService: MapService) {
  return async (req: Request, res: Response) => {
    try {
      const userId = req.user.id; // предположим, что auth-мидлварь уже отработала
      const id = await mapService.createMapForUser(userId, req.body);
      res.status(201).json({ id });
    } catch (e) {
      res.status(400).json({ error: (e as Error).message });
    }
  };
}
```

* **KISS:** обработчик делает только две вещи – извлекает `userId` и вызывает сервис.
* **SoC:** HTTP-слой отделён от бизнес-логики (вся логика в `MapService`).

---

### Как именно учтены принципы

* **KISS (Keep It Simple, Stupid):**

  * Простые интерфейсы доменных сущностей (`Map`, `MapElement`).
  * Небольшие классы/функции с чёткой задачей (`MapApi.createMap`, `MapService.createMapForUser`, `createMapHandler`).

* **YAGNI (You Aren’t Gonna Need It):**

  * В `MapApi` реализован только метод `createMap` – без сложных фильтров, версий карт и т.п., пока нет таких требований.
  * В `MapService` нет сложных сценариев версионирования/ветвления карты – добавим только, если это появится в постановке.

* **DRY (Don’t Repeat Yourself):**

  * Общий `HttpClient` инкапсулирует работу с `fetch`, вместо повторения кода по всем экранам.
  * `MapRepository` и его реализация в одном месте описывают, как писать данные в Firestore.

* **SOLID:**

  * **SRP:** `MapApi` только вызывает backend, `MapService` только реализует бизнес-логику, `FirestoreMapRepository` только пишет в БД.
  * **OCP:** можно добавить новые типы элементов или валидацию, расширяя код сервисов, не меняя интерфейсы.
  * **LSP/ISP:** интерфейсы небольшие (`HttpClient`, `MapRepository`), реализациям легко следовать.
  * **DIP:** зависимости идут через абстракции (`MapRepository`, `HttpClient`), а не через конкретные классы.
```
```
