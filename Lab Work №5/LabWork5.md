# Лабораторная работа №5  
**Тема:** Реализация архитектуры на основе сервисов (микросервисной архитектуры)  
**Проект:** *Mental Maps*  
**Цель работы:** получить опыт организации взаимодействия сервисов с использованием контейнеров Docker.

## 1. Реализация контейнеров и их взаимодействие

### 1.1 Реализованные контейнеры
В рамках работы реализованы и запущены следующие контейнеры:

- **`db` (PostgreSQL)** — база данных приложения  
  Назначение: хранение данных ментальных карт (карты, элементы, жалобы).

- **`backend` (REST API)** — серверная часть приложения  
  Назначение: обработка запросов клиента по HTTP, реализация REST API `/api/v1/...`, доступ к данным в БД.

- **`frontend` (Nginx + UI)** — клиентская часть приложения  
  Назначение: выдача простой web-страницы для демонстрации работоспособности и **проксирование** API-запросов на backend.

> Контейнеры запускаются через Docker Compose, что обеспечивает общую сеть для взаимодействия сервисов и удобный запуск/остановку.

### 1.2 Настройка взаимодействия сервисов
Взаимодействие организовано следующим образом:

1. Пользователь открывает интерфейс по адресу **`http://localhost:8080`**.
2. Контейнер **frontend (nginx)**:
   - отдаёт страницу UI,
   - принимает запросы к API (`/api/v1/...`) и **проксирует** их на контейнер **backend**.
3. Контейнер **backend** обрабатывает запрос и при необходимости выполняет операции чтения/записи в **PostgreSQL (db)**.
4. Ответ возвращается пользователю (через frontend, если запрос пришёл через прокси).

### 1.3 Точки входа и проверка работоспособности
Для демонстрации работоспособности используются следующие URL:

- **Backend напрямую (проверка сервиса):**  
  `http://localhost:3000/api/v1/health`  
  Ожидаемый результат: JSON с `"status":"ok"`.

- **Backend через прокси frontend (проверка взаимодействия frontend → backend):**  
  `http://localhost:8080/api/v1/health`  
  Ожидаемый результат: тот же JSON `"status":"ok"`, что подтверждает работу nginx-прокси.

- **UI (клиент):**  
  `http://localhost:8080`  
  Ожидаемый результат: страница с кнопками/полями для вызова API (Health, работа с картами и элементами).

- **Docker Desktop:** видны запущенные контейнеры `db-1`, `backend-1`, `frontend-1` и проброшенные порты `3000:3000` и `8080:80`.
  

---

## 2. Непрерывная интеграция (CI): сборка docker-образов

### 2.1 Что настроено
Настроен CI-пайплайн в **GitHub Actions**, который автоматически выполняется при пуше/PR и включает:

- получение исходного кода репозитория (`checkout`);
- настройку окружения сборки Docker (Buildx);
- сборку docker-образов;
- запуск сервисов в контейнерах (через Docker Compose);
- дальнейший прогон интеграционных тестов (см. п.3);
- остановку сервисов и очистку ресурсов.

### 2.2 Подтверждение выполнения требования
На скриншоте GitHub Actions видно успешное выполнение workflow/job (статус *succeeded*), а также этапы пайплайна, включая сборку и запуск контейнеров.


---

## 3. Интеграционные тесты и подключение в CI

### 3.1 Реализация интеграционных тестов
Интеграционные тесты проверяют совместную работу нескольких сервисов, а именно:
- корректную работу **backend API**;
- доступ к данным через **db (PostgreSQL)**;
- корректность ключевых сценариев на уровне API.

Для автоматизации тестирования использованы тесты в стиле Postman, запускаемые в CI через **Newman** (Postman CLI runner).

### 3.3 Интеграция тестов в CI
Интеграционные тесты включены в CI-процесс: после старта сервисов GitHub Actions запускает прогон тестов.  
На скриншоте workflow видно отдельный шаг запуска тестов, после чего workflow завершается успешно.

---

## Вывод
По результатам лабораторной работы №5:

- реализована архитектура из **3 контейнеров** (frontend + backend + db) и настроено их взаимодействие;
- продемонстрирована работоспособность приложения через healthcheck напрямую и через прокси, а также через UI;
- настроен CI (сборка docker-образов и запуск контейнеров);
- разработаны и подключены интеграционные тесты Postman в процесс CI.

---
